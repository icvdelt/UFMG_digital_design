library IEEE;
use IEEE.STD_LOGIC_1164.all;
use IEEE.NUMERIC_STD.all;
use IEEE.MATH_REAL.ceil;
use IEEE.MATH_REAL.log2;

entity mux is
	generic (
		NUMBER_OF_INPUTS : natural := 4;
		NUMBER_OF_BITS_PER_INPUT : natural := 4;
		INDEX_LENGHT : natural := integer(ceil(log2(real(4)))));
	port (
		rst : in std_logic;
		en : in std_logic;
		i_index : in std_logic_vector ((INDEX_LENGHT - 1) downto 0);
		i_data : in std_logic_vector ((NUMBER_OF_BITS * NUMBER_OF_BITS_PER_INPUT - 1) downto 0);
		o_data : out std_logic_vector ((NUMBER_OF_BITS - 1) downto 0));
end mux;

architecture bh_mux of mux is
	begin
		store : process (rst, en, i_index, i_data)
			begin
				if (rst = '1') then --Clears the register asynchronously.
					o_data <= (others => '0');
				elsif (en =  '1') then 
					if (to_integer (unsigned (i_index)) = 0) then
					o_data <= i_data (3 downto 0);
					for it0 in 1 to (NUMBER_OF_INPUTS - 1) loop	--Checks all possible combinations for the index.
						elsif (to_integer (unsigned (i_index)) = it0) then
							o_data <= i_data ((4 * (it0 + 1) - 1) downto (4 * it0));
					end loop
					else
						o_data <= (others => '0');
					end if;
				else
					o_data <= (others => '0');
				end if;
		end process;
end bh_mux;